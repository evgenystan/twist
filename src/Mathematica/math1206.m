(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(*XML generating utilities
accepts specially formatted data structure:
data = String | {item,{data,data,...}}
item = String | {nodeName,{attrName,attrValue},{attrName,attrValue},...}

 Usage
makeXMLDocument[
{{"root",{"id","none"},{"class","none"}},
{"item",
"text",
{"item",
"text"
},
{{"item",{"special","yes"}},
"Special text"
},
{"item",
"text"
}
},
{"item",{"item"}}
}]
*)
makeXMLDocument[data_List]:=StringJoin["<?xml version='1.0' encoding='UTF-8'?>",makeXMLNode[data]];
makeXMLNode[node_List]:= 
If[Length[node]==1,
StringJoin["<",openXMLNode[node[[1]]],"/>\n"],
StringJoin["\n<",openXMLNode[node[[1]]],">",StringJoin@@Map[makeXMLNode[#]&,Drop[node,1]],"</",closeXMLNode[node[[1]]],">"]
]

makeXMLNode[text_String]:=StringReplace[ExportString[XMLElement["t",{},{text}],"XML","Entities"->"HTML"],{StartOfString~~"<t>"->"","</t>"~~EndOfString->""}]

openXMLNode[name_String]:=name
closeXMLNode[name_String]:=name

openXMLNode[list_List]:=StringJoin[
ToString[list[[1]]],
makeXMLAttributes[Drop[list,1]]
]
closeXMLNode[list_List]:=ToString[list[[1]]]

makeXMLAttribute[attr_List]:=StringJoin[" ",ToString[attr[[1]]],"='",ToString[attr[[2]]],"'"]
makeXMLAttributes[attrs_List]:=Apply[StringJoin,Map[makeXMLAttribute,attrs,{1}]]
(*end of XML utilities*)

(*HTML utilities*)
(*Wraps LaTeX for MathJax rendering*)
htmlLatex=StringJoin["<script type='math/tex'>",#,"</script>"]&;

(*Wraps LaTeX for MathJax rendering in display mode*)
htmlLatexDisplay=StringJoin["<script type='math/tex; mode=display'>",#,"</script>"]&;

(*Wrap the text in appropriate HTML tags to be displayed as a problem prompt*)
Options[htmlPrompt]={promptId->""};
SetOptions[htmlPrompt,promptId->""];

htmlPrompt [title_String,body_String,OptionsPattern[]]:=StringJoin["<div><h2>"<>title<>"</h2></div><div promptId='"<>OptionValue[promptId]<>"'><p>"<>body<>"</p></div>"];
htmlPrompt [body_String,OptionsPattern[]]:=StringJoin["<div promptId='"<>OptionValue[promptId]<>"'><p>"<>body<>"</p></div>"];

(*Generate an input field*)
htmlInputField [fieldId_,OptionsPattern[]]:="<span class='inputfield' style='font-size: 100%; font-family: STIXGeneral-Regular; ' contenteditable='true' fieldId = '"<>fieldId<>"'></span>"
(*Set default options for htmlInputField*)
Options[htmlInputField] = {Enabled->True};
SetOptions[htmlInputField,Enabled->True];


(*Put all input fields together and supply them with a 'Submit' button*)
htmlInputFieldBuilder [ problemId_,prompt_, fields_,OptionsPattern[]]:=
StringJoin["<div promptId = '",problemId,"' class='inputbox'>",prompt,"&nbsp;",fields<>"&nbsp;<input promptId = '",problemId,"' class='evalButton' type='button' value='Submit'",If[OptionValue[Enabled],""," disabled='true'"]," />&nbsp;<span id='resultsField",problemId,"'></span></div>"]
(*Set default options for htmlInputFieldBuilder*)
Options[htmlInputFieldBuilder] = {Enabled->True};
SetOptions[htmlInputFieldBuilder,Enabled->True];
(*end of HTML utilities*)


(*Transform a Mathematica expression into a LaTeX string. A few helpful substitutions are performed for a better output*)
tFq=Block[{dummy},StringReplace[ToString[#/.dummy'[_]->1,TeXForm],{"=="->"\[LongEqual]","\[Equal]"->"\[LongEqual]","capitalC"->"C","zzone"->"1","dummy"->"","zdummy"->"","log"->"ln"}]]&;

(*Set default options for makeproblem*)
Options[makeproblem] = {Enabled->True};
SetOptions[makeproblem,Enabled->True];


probleminfo[{"1206.21"}]={"A u-substitution problem"};

makeproblem[{"1206.21"},str_,opts___]:=
Module[
{xmlResponse,
prompt = Null,numberOfTries = 0,optionsString =  Null, evalString = Null, testString=Null,
fetchPrompt=Null,supplyPrompts=Null,fetchOnlyIfRight = True,reFetchIfUpdate = True,dependencies=Null,
 a,b,u,uprime,f,F},
Block[{x,uu,ff,FF,aa,bb},
F=RandomChoice[{Exp,Tan,ArcTan,ArcSin,Log}];
u=RandomChoice[{Cos,Sin,Exp,(#^2)&,(#^3)&,Sqrt[#]&}];
{a,b} = RandomChoice[{1,2,3,4,5,1/2,3/2,1/3,5/3,4/3},2];
f=D[a F[u[b x]],x];
prompt = htmlPrompt["Integration by subsitution","Consider the integral "<>htmlLatexDisplay[tFq[Defer[Integrate[#,x]]]&[f]]];
optionsString =ToString[ {uu->u,ff->f,FF->F,aa->a,bb->b},InputForm];
supplyPrompts = {{"1206.21.1",Enabled->True},{"1206.21.2",Enabled->False}};

(*Make an XML with special characters encoded as ENTITY_REFERENCE.*)
xmlResponse = XMLObject["Document"][{XMLObject["Declaration"]["Version"->"1.0","Encoding"->"UTF-8"]},
XMLElement["problemData",{},{
XMLElement["prompt",{},{prompt}],
XMLElement["optionsString",{},{optionsString}],
XMLElement["supplyPrompts",{},Map[XMLElement["id",{"enabled"->ToString[ReplaceAll[Enabled,#[[2]]]]},{#[[1]]}]&,supplyPrompts,{1}]]
}]
,{}];
Return[ExportString[xmlResponse,"XML","Annotations" ->{"DocumentHeader","XMLDeclaration"}]];
]
];


makeproblem[{"1206.21.1"},str_,opts__]:=
Module[
{xmlResponse,
prompt = Null,numberOfTries = 0,optionsString =  Null, evalString = Null, testString=Null,
fetchPrompt=Null,supplyPrompts=Null,fetchOnlyIfRight = True,reFetchIfUpdate = True,dependencies=Null,
 a,b,u,uprime,f,F,test,on},
Block[{x,uu,ff,FF,Enabled,promptId},
{u,f,F}=ReplaceAll[{uu,ff,FF},{opts}];
prompt =StringJoin[
htmlPrompt[ "Suggest a u-substitution that will simplify the integral.",promptId->"1206.21.1"],
htmlInputFieldBuilder["1206.21.1","<span>u(x) = </span>",htmlInputField["uSub"],Sequence[FilterRules[{opts},{Enabled}]]]
];
test := Module[{uSub},uSub = StringReplace["uSub",{##}];
Catch[If[Not[SyntaxQ[uSub]],Throw[makeXMLDocument[{{"testResponse",{"accepted","false"}},{"comment","Syntax Error"},{{"comment",{"fieldId","uSub"}},"Syntax error after \""<>StringTake[uSub,Min[SyntaxLength[uSub],StringLength[uSub]]]<>"\""}}]],
Block[{x},
uSub=ToExpression[
StringReplace[
StringReplace[uSub,WordBoundary~~"e"~~WordBoundary->"E"],{WordBoundary~~"x"~~Whitespace~~"("->"x*(",WordBoundary~~"x("->"x*(",WordBoundary~~"E"~~Whitespace~~"("->"E*(",WordBoundary~~"E("->"E*("}
],TraditionalForm];
If[NumberQ[Simplify[(uSub)/x]],
Throw[makeXMLDocument[{{"testResponse",{"accepted","false"},{"promptId","1206.21.1"}},{"comment","Substitution must not be a multiple of x"},{{"comment",{"fieldId","uSub"}},"Substitution must not be a multiple of x"}}]]
,
If[Not[NumericQ[Simplify[(uSub)/.x->1]]],
Throw[makeXMLDocument[{{"testResponse",{"accepted","false"},{"promptId","1206.21.1"}},{"comment","Substitution must be a function of x only."},{{"comment",{"fieldId","uSub"}},"Check if there are variables other than x."}}]]
,
Throw[makeXMLDocument[{{"testResponse",{"accepted","true"},{"promptId","1206.21.1"}},{{"comment",{"fieldId","uSub"}},"Accepted"},{"enablePrompt",{"id","1206.21.2"}}}]]
]
];
]
];]]&;
testString = ToString[test,InputForm]<>"@@";

(*Make an XML with special characters encoded as ENTITY_REFERENCE.*)
xmlResponse = XMLObject["Document"][{XMLObject["Declaration"]["Version"->"1.0","Encoding"->"UTF-8"]},
XMLElement["problemData",{},{
XMLElement["prompt",{},{prompt}],
XMLElement["testString",{},{testString}]
}]
,{}];
Return[ExportString[xmlResponse,"XML","Annotations" ->{"DocumentHeader","XMLDeclaration"}]];
];
];


makeproblem[{"1206.21.2"},str_,opts___]:=
Module[
{xmlResponse,
prompt = Null,numberOfTries = 0,optionsString =  Null, evalString = Null, testString=Null,
fetchPrompt=Null,supplyPrompts=Null,fetchOnlyIfRight = True,reFetchIfUpdate = True,dependencies=Null,
 a,b,u,uprime,f,F,test},
Block[{uu,ff,FF,Enabled,promptId},
f=ReplaceAll[ff,{opts}];
prompt =StringJoin[
htmlPrompt["Apply your proposed substitution to the integral above.",promptId->"1206.21.2"],
htmlInputFieldBuilder["1206.21.2","",
"<span style='display: inline-block; position: relative; font-size: 104%;'>
<span class='mo' style='font-family: STIXIntegralsD; vertical-align: -0.615em; '>&#x222B;</span>
<span class='mrow'>"<>htmlInputField["integrand"]<>"</span>
<span class='mspace' style='height: 0em; vertical-align: 0em; width: 0.188em; display: inline-block; overflow: hidden; '></span>
<span class='mi' style='font-family: STIXGeneral-Italic; '>d</span>
<span class='mrow'>"<>htmlInputField["variable"]<>"</span></span>",Sequence[FilterRules[{opts},{Enabled}]]]
];
test =ReplaceAll[ Module[{uSub,var,int,ok=True,comment="",commentvar="",commentint=""},
Catch[
{uSub,var,int} =  StringReplace[{"uSub","variable","integrand"},{##}];
var = StringReplace[var,Whitespace->""];
If[Not[LetterQ[var]],
ok=False;
comment = "The differential of the integral must be a single variable. ";
commentvar = "This does not seem to be a valid variable name.";,
If[Not[SyntaxQ[var]],
ok=False;
comment = comment <> "Your input cannot be interpreted as an integral. ";
commentvar = "This does not seem to be a valid variable name.";
];
];
If[Not[SyntaxQ[int]],
ok=False;
comment = comment <> "Your input cannot be interpreted as an integral";
commentint = "Your integrand has a syntax error at or after **"<>StringTake[int,Min[SyntaxLength[int],StringLength[int]]]<>"**";
];
If[ok,
Block[{x,uVar},
int = ToExpression[
StringReplace[
StringReplace[
StringReplace[
int,
{WordBoundary~~"e"~~WordBoundary->"E",
start:Except[LetterCharacter]~~"e"~~end:Except[LetterCharacter]:>start<>"E"<>end,
WordBoundary~~"e"~~end:Except[LetterCharacter]:>"E"<>end,
start:Except[LetterCharacter]~~"e"~~WordBoundary:>start<>"E"
}],
{WordBoundary~~var~~Whitespace~~"("->var<>"*(",WordBoundary~~var~~"("->var<>"*(",WordBoundary~~"E"~~Whitespace~~"("->"E*(",WordBoundary~~"E("->"E*("}
],
var -> "uVar"
]
,TraditionalForm];
uSub=ToExpression[
StringReplace[
StringReplace[uSub,WordBoundary~~"e"~~WordBoundary->"E"],{WordBoundary~~"x"~~Whitespace~~"("->"x*(",WordBoundary~~"x("->"x*(",WordBoundary~~"E"~~Whitespace~~"("->"E*(",WordBoundary~~"E("->"E*("}
],TraditionalForm];
If[PossibleZeroQ[
Simplify[
ff-ReplaceAll[int,uVar->uSub] D[uSub,x]
]
],
Throw[makeXMLDocument[{{"testResponse",{"correct","true"},{"promptId","1206.21.2"}},{"comment","Great!"}}]],
Throw[makeXMLDocument[{{"testResponse",{"correct","false"},{"promptId","1206.21.2"}},{"comment","Your integral does not match the original one."},{{"comment",{"fieldId","integrand"}},"This does not evaluate to match the original integral."}}]]
]
],
Throw[makeXMLDocument[{{"testResponse",{"correct","false"},{"promptId","1206.21.2"}},{"comment",comment},{{"comment",{"fieldId","variable"}},commentvar},{{"comment",{"fieldId","integrand"}},commentint}}]]
];
]
]&,{opts}];
testString = ToString[test,InputForm]<>"@@";
dependencies = {"1206.21.1"};
(*Make an XML with special characters encoded as ENTITY_REFERENCE.*)
xmlResponse = XMLObject["Document"][{XMLObject["Declaration"]["Version"->"1.0","Encoding"->"UTF-8"]},
XMLElement["problemData",{},{
XMLElement["prompt",{},{prompt}],
XMLElement["testString",{},{testString}],
XMLElement["dependencies",{},Map[XMLElement["id",{},{#}]&,dependencies]]
}]
,{}];
Return[ExportString[xmlResponse,"XML","Annotations" ->{"DocumentHeader","XMLDeclaration"}]];
];
];



