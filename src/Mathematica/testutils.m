(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Off[General::"spell"];
Off[General::"spell1"];


STATEMENT = "0";
FREERESPONSE = "1";
MULTIPLECHOICE = "2";


SetOptions[Plot,BaseStyle->{FontFamily->"Chalkboard",FontSize->14,FontColor->RGBColor[0,0,0]}];
SetOptions[ListPlot,BaseStyle->{FontFamily->"Chalkboard",FontSize->14,FontColor->RGBColor[0,0,0]}];
(* 
 The following should be set in frontend init file
*)

If[ $FrontEnd!=Null, SetOptions[$FrontEnd, NumberMultiplier->"\[Cross]"]];
SetOptions[PaddedForm,NumberMultiplier->"\[Cross]"];
SetOptions[NumberForm,NumberMultiplier->"\[Cross]"];
SetOptions[ScientificForm,NumberMultiplier->"\[Cross]"];
SetOptions[EngineeringForm,NumberMultiplier->"\[Cross]"];
SetOptions[AccountingForm,NumberMultiplier->"\[Cross]"];

(**used to control parenthesis printing in logs**)
Unprotect[Log];
Format[Log[dummy[x_]]]:=Log[x];
Protect[Log];
(********************************)

numberJoin[x_?NumberQ,y_?NumberQ]:=ToExpression[ToString[x]<>ToString[y]];
numberJoin[x_?NumberQ,y_?NumberQ,z__]:=numberJoin[ToExpression[ToString[x]<>ToString[y]],z];SetAttributes[numberJoin,Listable];

(***************************************************)
(*Complex variable and function utilities*)
cC[z_]:=ReplaceAll[z,Complex[mvar_,nvar_]->Complex[mvar,-nvar]];
rePart[z_]:=ComplexExpand[(z+cC[z])/2];
imPart[z_]:=ComplexExpand[(z-cC[z])/2/I];

cpx=#.{1,I}&;

const=Subscript[capitalC,#]&;

(**************************************************)
(*Formats answers into proper form Usage:Let w={correct answer,wrong answer,....} ProblemText[str]=Join[{{"Problem",{...}},{"Comment",{...}}},answers[w]];*)

ansLabels[nw_]:=Nest[Join[#,{"Wrong"}]&,{"Right"},nw];

buildAns:=Apply[{#1,{#2}}&,Transpose[{#1,#2}],{1}]&;

answers=buildAns[ansLabels[Length[#1]-1],(If[MatchQ[Head[#1],String]||gQ[#],#1,tFq[#1]])&/@#1]&;
(**************************************************)
(**Formats numbers as dollars***)

money:=tF[NumberForm[If[IntegerQ[#1],#1,N[#]],{12,2},NumberSigns->{"-$","$"},NumberPadding->{"",If[IntegerQ[#1],"","0"]},NumberPoint->If[IntegerQ[#1],"","."],DigitBlock->3,NumberSeparator->","]]&;

(**************************************************)

sQ[prob_?VectorQ]:=Module[
{},
makeproblem[prob,"A"];
printHeader["*****>  Problem Identifier = "<>tFq[prob]];
Column[ImportString[#,"Base64"]&/@(makeCodedGif/@(MakeCell/@Flatten[ProblemText["A"]]))]
];

(**************************************************)
(*test if object is a graphics object*) (*20111009 - removed Head Grid & added 3  *)
gQ=MemberQ[{Graphics,Image,GraphicsGrid,DensityGraphics,GraphicsArray,ContourGraphics,Graphics3D,SurfaceGraphics,GraphicsRow,GraphicsColumn,GraphicsComplex},Head[#]]&;
(**************************************************)
(*A specialty utility designed for a particular problem*)

AllElmntsMoved[listin_]:=Module[{listout={},i,tf},
tf=Apply[Or,Apply[SameQ,(Transpose[{listin[[1]],#}]&/@listin),{2}],{1}];
For[i=1,i<=Length[listin],i++,listout=If[tf[[i]],listout,Append[listout,listin[[i]]]]];
listout];
(**************************************************)
(*******************************************)
(*   legacy    *)

DistinctPairs[v_List]:=Subsets[v,{2}];
(**************************************************)
(*Domain[f] gives a list of {args} for which f[args] is defined.  Apply f to get value;
f@@Domain[f][[j]] returns the value on jth element of the domain.*)


Domain[f_]:=(Apply[List,#[[1]],2][[1]])&/@DownValues[f];

(**************************************************)

closest=Sqrt[Min[(Flatten[#[[1]]-#[[2]]].Flatten[#[[1]]-#[[2]]]&)/@Subsets[#,{2}]]]&;

(*MinDist returns the distance between the nearest neighbors among the elements of the input list.Elements are numbers*)

MinDist=(Min[(Abs[#[[1]]-#[[2]]]&)/@Subsets[#,{2}]])&;

(* 
Boolean. Returns True if if a pair of values are closer together than 5% of their magnitude.
*)

mD[pts_List] :=mD[pts,.05];

mD[pts_List,tolerance_]:=Module[{ctr=Mean[pts]},
If[Length[Union[Chop[pts]]]==1,
True,
Or@@(Abs[#1[[1]]-#1[[2]]]<tolerance Max[Abs[#1[[1]]-ctr],Abs[#1[[2]]] -ctr]&/@ Subsets[pts,{2}])  ]
];

(**************************************************)
(*Remove duplicate elements,perserving order of list*)

uUnion[\[ScriptL]_List]:=DeleteDuplicates[\[ScriptL]];
uUnion[li_List,z___]:=DeleteDuplicates[Join[li,z]];

OrderedUnion=uUnion;
(**************************************************)
(*ChooseRandom[list,nr] with'nr' an Integer returns a random sublist of'list' of length'nr' If nr<0 is sorted*)

ChooseRandom[list_List]:=RandomSample[list];

ChooseRandom[list_,nr_Integer]:=Which[
Length[list]==0,{},
nr==0,{},
nr<0,Sort[ChooseRandom[list,-nr]],
nr>Length[list],
Module[
{lsize=Length[list],m,n},
{m,n}=QuotientRemainder[nr,lsize];Join[Flatten[Table[RandomSample[list],{m}],1],RandomSample[list,n]]],
True,RandomSample[list,nr]
];

(*ChooseRandom[list,nr] with'nr' a nested list of integers returns a list in which numbers in'nr' are replaced by that number of elements of'list'.The full collection of elements is a random sublist of'list'.When an entry is negative the sublist is sorted*)

ChooseRandom[list_,nr_List]:=If[And@@(IntegerQ/@Flatten[nr]),
Module[
{totl,tempflat,templist,pos,usd,nrpart,temppart},
totl=Total[Abs/@Flatten[nr]];
tempflat=ChooseRandom[list,totl];
templist=nr;
pos=Reverse[Position[nr,_Integer]];
usd=0;
(nrpart=Extract[nr,#];
temppart=Take[tempflat,{usd+1,usd+Abs[nrpart]}];
usd=usd+Abs[nrpart];
If[nrpart<0,temppart=Reverse[Sort[temppart]]];
templist=If[nrpart==0,Delete[templist,#],ReplacePart[templist,temppart[[1]],#]];
Do[templist=Insert[templist,temppart[[j+1]],#],{j,Length[temppart]-1}])&/@pos;
templist]
];

(**************************************************)
(*PowerSet returns the power set of the given list. Elements of the list are treated as distinct.  Nest Union inside if that is not desired.*)

PowerSet=Subsets;

(**************************************************)
(*RandomSign returns+/-1 with equal probability*)
RandomSign[]:=2RandomInteger[]-1;
randSign=rSign=RandomSign;
rspin:=RandomSign[];

RandomBoolean[]:= RandomInteger[]==0;
randBoolean=rBool=RandomBoolean;
rB:= RandomInteger[]==0;

(**************************************************)
(*
sf rounds the argument x to n significant figures for presentation 
If n is not given, 3 significant figures are returned
*)

SetAttributes[sf,Listable];
sf[x_] := sf[x, 3]
 
sf[xx_, n_] := Module[
{d,m,t,x},
If[!NumericQ[xx], Return[xx]];
If[Head[xx] == Complex,Return[sf[Re[xx], n] + I*sf[Im[xx], n]]];
x=Chop[xx];
{t,m}=RealDigits[N[xx],10,n+1];
d=If[t[[n+1]]<5,FromDigits[{Take[t,n],m}]
,FromDigits[{Join[Take[t,n-1],{t[[n]]+1}],m}]  ];
Sign[xx] If[IntegerQ[d],d,N[d]]
];

(**************************************************)

StringReplaceRepeated[s_String,rules___]:=FixedPoint[StringReplace[#,rules]&,s];

(**************************************************)

(*Simple shortcuts to put an expression or equation into a traditional form string*)

tF[aA_]:="<script type='math/tex'>"<>ToString[ToString[aA,TraditionalForm],TeXForm]<>"</script>";

(*TeXForm should handle matrices correctly additional processing will be required
tF[a_?MatrixQ]:=StringReplace[tF[mdummy[TableForm[a,TableSpacing->{2,2},TableAlignments->Right]]],"mdummy"->""];*)

(*Transform a Mathematica expression into a LaTeX string. A few helpful substitutions are performed for a better output*)
tFq[math_,OptionsPattern[]]:=Block[{dummy,DisplayMath},"<script type='math/tex"<>If[OptionValue[DisplayMath],"; mode=display",""]<>"'>"<>StringReplace[ToString[math/.dummy'[_]->1,TeXForm],{"=="->"\[LongEqual]","\[Equal]"->"\[LongEqual]","capitalC"->"C","zzone"->"1","dummy"->"","zdummy"->"","log"->"ln"}]<>"</script>"]
Options[tFq]={DisplayMath->False};


tFqa:="<script type='math/tex'>"<>StringReplace[ToString[#/.dummy'[_]->1,TeXForm],{"=="->"\[LongEqual]","\[Equal]"->"\[LongEqual]","capitalC"->"C","zzone"->"1","dummy"->"","zdummy"->"","log"->"ln","{"->"\[LeftAngleBracket]","}"->"\[RightAngleBracket]"}]<>"</script>"&;

tFb:=StringReplace[tF[#1],{"{"->"[","}"->"]"}]&;

(**************************************************)

tForm=Block[{dummy},"<script type='math/tex'>"<>StringReplace[ToString[#/.dummy'[_]->1,TeXForm],{"=="->"\[LongEqual]","\[Equal]"->"\[LongEqual]","capitalC"->"C","zzone"->"1","dummy"->"","zdummy"->"","log"->"ln"}]<>"</script>"]&;
(*TeXForm should handle fractions correctly
tf:=TraditionalForm[DisplayForm[If[Denominator[#]===1,#,FractionBox[Numerator[#],Denominator[#]]]]]&;

tFqa:=StringReplace[tF[#/.dummy'[_]->1],{"=="->"\[LongEqual]","=="->"\[LongEqual]","capitalC"->"C","zzone"->"1","dummy"->"","zdummy"->"","log"->"ln","{"->"\[LeftAngleBracket]","}"->"\[RightAngleBracket]"}]&;

tFb:=StringReplace[tF[#1],{"{"->"[","}"->"]"}]&;

tf:=TraditionalForm[DisplayForm[If[Denominator[#]===1,#,FractionBox[Numerator[#],Denominator[#]]]]]&;*)

ClearAll[cartesianVector];
cartesianVector[x_,y_]:=tFq[dummy[x,y]];

cartesianVector[x_List]:=tFq[dummy@@x];

columnVector=tFq[Partition[#,1]]&;

rowVec=cartesianVector;

colVec=columnVector;

angBrac=StringReplace[tFq[#],{"{"->"\[LeftAngleBracket]","}"->"\[RightAngleBracket]"}]&;

overBar=OverBar[Underoverscript[#,"",dummy]]&;

overVector=OverVector[Underoverscript[#,"",dummy]]&;

superSuperscript[x_,y_,z_]=Style[Superscript[x,Superscript[y,z]],ScriptBaselineShifts->{Automatic,1.5`}];

superSuperscript[x_,y_]=Style[Superscript[x,y],ScriptBaselineShifts->{Automatic,1.5`}];

ToDumbVector[l_?(VectorQ[#]&&Length[#]<4&)]:=Module[{locall},locall=Take[Join[l,{0,0,0}],3];
ToString[(#.(OverHat/@toBold/@{"i","j","k"}))&@locall,StandardForm]];

(**************************************************)
(************************
New formatting control functions added  -mw  20100714

		explicitNegQ[expr] returns True if expr has an explicit "-" out front
							otherwise it returns False
		wrapIfNeg[expr] returns "(tFq[expr])" if explicitNegQ[expr] is true, 
								tFq[expr] otherwise. Output is a string.
		keepOrderPlus[ x, y ]  returns a presentation of "x + y",
					in this order regardless of the signs of x and y
		keepOrderTimes[ x, y ]  returns a presentation of "x \[Cross] y",
					in this order regardless of the signs of x and y
                    If y<0, it is wrapped in parentheses
**************************)
explicitNegQ[expr_?NumericQ]:=If[expr<0,True,False];
explicitNegQ[expr_]:=MatchQ[Head[expr],Times]&&MatchQ[expr[[1]],_?Negative];

wrapIfNeg[expr_]:=tFq[If[explicitNegQ[expr],dummy[expr],expr]];

keepOrderPlus[x_,y_]:=
Which[
MatchQ[x,0],tFq[y],
MatchQ[y,0],tFq[x],
True,tFq[x]<>If[explicitNegQ[y],"\[ThinSpace]-\[ThinSpace]"<>tFq[-y],"\[ThinSpace]+\[ThinSpace]"<>tFq[y]]];

keepOrderTimes[x_,y_]:=
Which[
MatchQ[x|y,0],tFq[0],
MatchQ[y,Null],tFq[x],
True,wrapIfNeg[x]<>"\[ThinSpace]"<>wrapIfNeg[y]
];

(**************************************************)
(*toBold encloses a string in a Style wrapper for bold printing*)
ToBold[st_String]:=toBold[st];
toBold[st_String]:=Style[st,FontWeight->"Bold"];
(**************************************************)
(*This is a processing utility for serialization of files in hex*)

toHexString[t_]:=toHexString[t,10];

toHexString[t_,n_]:=Module[{s},s="00000000000000000"<>ToString[BaseForm[t,16]];
s=StringDrop[s,{StringPosition[s,"\n",1][[1,1]],StringLength[s]}];
StringTake[s,-n]];

(**************************************************)

ToSystem[coefmatrix_,const_,varname_String]:=If[MatrixQ[coefmatrix]&&ListQ[const]&&Length[coefmatrix]==Length[const],TableForm[Table[{DisplayForm[Sum[coefmatrix[[j,k]]*ToExpression["\("<>varname<>"\_"<>ToString[k]<>"\)"],{k,Length[coefmatrix[[j]]]}]],"=",const[[j]]},{j,Length[coefmatrix]}]]];

(**************************************************)
(******
x should be a string or a list of strings 
Modified 30 Mar 06 
now accepts variable lists  (instead of only subscripted vars)
******)

displayDE[A_?VectorQ,d_,dvar_Symbol]:=displayDE[{A},If[MatchQ[Head[d],List],d,{d}],dvar];

displayDE[A_?VectorQ,d_,dvar_Symbol,ivar_Symbol]:=displayDE[{A},If[MatchQ[Head[d],List],d,{d}],dvar,ivar];

displayDE[A_?MatrixQ,d_?VectorQ,dvar_Symbol]:=systemGridBox[A,d,Reverse[(Derivative[#][dvar]&/@Range[0,Length[A[[1]]]-1])]];

displayDE[A_?MatrixQ,d_?VectorQ,dvar_Symbol,ivar_Symbol]:=systemGridBox[A,d,Reverse[(D[dvar[ivar],{ivar,#}]&/@Range[0,Length[A[[1]]]-1])]];

displayDE[A_?MatrixQ,d_,dvar_Symbol]:=displayDE[A,Table[d,{Dimensions[A][[1]]}],dvar];


makeGridRow[a_?VectorQ,d_,x_List]:=Module[
{b,formatTerm},
If[Length[a]!=Length[x],
Return["makeGridRow: BAD DATA"]
];
b=If[MatchQ[Plus,Head[#]],dummy[#]  ,#  ]&/@a;
formatTerm[n_Integer]:=ReleaseHold[
If[MatchQ[b[[n]],0]||MatchQ[Chop[b[[n]]],0],
HoldForm[Sequence["","",""]],
If[explicitNegQ[b[[n]]],HoldForm[Sequence["\[ThinSpace]-\[ThinSpace]",If[MatchQ[b[[n]],-1],"",-b[[n]]],"\[ThinSpace]",x[[n]]]],HoldForm[Sequence[If[And@@(MatchQ[#1,0]&)/@Chop/@Take[b,n-1],"","\[ThinSpace]+\[ThinSpace]"],If[b[[n]]===1,"",b[[n]]],"\[ThinSpace]",x[[n]]]]]]];

Join[formatTerm/@Range[Length[a]],{"\[ThinSpace]\[LongEqual]\[ThinSpace]",tF[d]}]
];

(*********************************************)

systemGridBox[A_?MatrixQ,d_?VectorQ,vars_]:=Module[
{j,m,n,x,xx},
{m,n}=Dimensions[A];
x=vars;
If[m!=Length[d],Return["uh oh, bad data -rows- [systemGridBox]"]];
If[MatchQ[vars,_String],x=ToExpression[vars]];

xx=If[MatchQ[Head[x],List],
x,
(Subscript[x,#1]&)/@Range[n]
];
tFq@Grid[Table[makeGridRow[A[[j]],d[[j]],xx],{j,m}],Alignment->{Right,Baseline},Spacings->Scaled[0]]
];

(**************************************************)
(*Returns a sequence of True/False corresponding to the binary expansion of k (0-7)*)

pick[k_Integer]:=((BitAnd[k,#]==#)&/@{1,2,4});

(**************************************************)
addlink[str_]:=" web reference '"<>str<>"' (click here)";
(**************************************************)
Block[{linkbase},linkbase="http://www.math.vt.edu/people/quinn/calc_refs/";
linkfor["Numerical Integration"]=linkbase<>"num_int.pdf";
linkfor["Proper and Improper Integrals"]=linkbase<>"prop_imp_ints.pdf";
linkfor["Derivatives of Integrals"]=linkbase<>"deriv_int.pdf";
linkfor["Integral Notations"]=linkbase<>"int_note.pdf";
linkfor["Improper Integrals"]=linkbase<>"improp_ints.pdf";
linkfor["Standard Integrals"]=linkbase<>"stand_ints.pdf";
linkfor["Substitution"]=linkbase<>"substitution.pdf";
linkfor["Completing the Square"]=linkbase<>"comp_square.pdf";
linkfor["Change of Variables"]=linkbase<>"change_vars.pdf";
linkfor[_]:="";];
(**************************************************)

(*random numerical entry*)
entry[mx_,mid_,den_]:=Module[{num},num=If[RandomInteger[{0,1}]>0,RandomInteger[{1-mx,mx}],RandomInteger[{1-mid,mid}]];
If[num<=0,num=num-1];
num/If[den<=1,1,RandomInteger[{1,den}]]];

(*random symbol entry*)

symbolentry[symb_,cof_,mx_,md_]:=Module[{},Which[cof<=0,symb,cof==1,symb*entry[mx,md,0],cof==2,symb+entry[mx,md,0],True,symb*entry[mx,md,0]+entry[mx,md,0]]];

(*find matrices with specified properties*)

FindMatrix[totros_,cls_,opts___]:=Module[{temp,ros,diag,ddepcols,openings,syros,syplace,zroplaces,temprow,r1,r2,c1,oldros},(*extract option information*){{depros,depcol},{mx,mid,den},{ech,rowop},returnops,{zros,nearness},{symb,syno,sydiag,synearness,sycoef}}={DependenceData,CoefficientData,EchelonData,ReturnRowOps,ZeroData,SymbolData}/.{opts}/.Options[FindMatrix];
ros=totros-depros;
temp=Table[{},{ros},{cls}];
(*echelon form*)diagplaces={};
If[ech>0,diag=Table[0,{cls}];
(*choose dependent depcolumns*)ddepcols=Which[depcol>1,ChooseRandom[Range[1,Min[{cls,ros}]],depcol],depcol==1,ChooseRandom[Range[2,Min[{cls,ros}]],depcol],depcol==0,{},depcol>-3,Join[{cls},ChooseRandom[Range[2,Min[{cls-1,ros}]],Abs[depcol]-1]],depcol<=-3,Join[{cls},ChooseRandom[Range[2,Min[{cls,ros}]],Abs[depcol]-1]]];
(*"diagonal" coords*)Do[If[Not[MemberQ[ddepcols,j]]&&Max[diag]<ros,diag[[j]]=Max[diag]+1],{j,cls}];
(*place echelon zeros*)Do[temp[[i,j]]=0,{j,cls},{i,Max[diag[[Range[1,j]]]]+1,ros}];
(*reduced echelon zeros*)If[ech>=3,Do[If[diag[[j]]<=ros,temp[[i,j]]=0],{j,cls},{i,diag[[j]]-1}]];
(*echelon 1s*)If[ech>1,Do[If[diag[[j]]>0&&diag[[j]]<=ros,temp[[diag[[j]],j]]=1],{j,cls}]];
(*diagonal places*)diagrows=Complement[Union[diag],{0}];
diagplaces=Table[Join[{diagrows[[i]]},Select[Range[1,cls],diag[[#]]==i&]],{i,Length[diagrows]}];];(*end echelon form*)(*find empty spots*)openings=Select[Flatten[Table[{i,j},{i,ros},{j,cls}],1],(temp[[#[[1]],#[[2]]]]=={})&];
If[ech>0,openings=Complement[openings,diagplaces]];
(*symbol placement*)syros={};
If[syno>0,Module[{i},Which[ech>0&&(sydiag==1||Length[diagplaces]<3),(*on diag*){syplace}=ChooseRandom[diagplaces,1];,ech>0&&sydiag>1,(*diagonal,not ends*){syplace}=ChooseRandom[Drop[Drop[diagplaces,-1],1],1];,ech>0&&sydiag==-1,(*off diagonal*){syplace}=ChooseRandom[openings,1];,ech>0&&sydiag<-1,(*off diagonal not ends*)midopenings=Select[openings,(#[[1]]!=1&&#[[1]]!=ros)&];
If[midopenings=={},midopenings=Select[openings,(#[[1]]!=ros)&]];
If[midopenings=={},midopenings=openings];
{syplace}=ChooseRandom[midopenings,1];,ech==0||sydiag==0,(*random*){syplace}=ChooseRandom[Union[openings,diagplaces],1];];
syros={syplace[[1]]};
temp[[syplace[[1]],syplace[[2]]]]=symbolentry[symb,sycoef,mx,mid];
openings=Complement[openings,{syplace}];]];
(*randomly placed zeros*)If[zros!=0,totalzros=Floor[Length[openings]*Abs[zros]+If[syros=={},0,.5]];
zroplaces=ChooseRandom[openings,totalzros];
(temp[[#[[1]],#[[2]]]]=0)&/@zroplaces;
openings=Complement[openings,zroplaces];];(*end place zeros*)(*fill openings*)Do[If[temp[[i,j]]=={},temp[[i,j]]=entry[mx,mid,den]],{i,ros},{j,cls}];
(*row ops in echelon case*)Which[rowop<0,cyc=ChooseRandom[Range[1,ros],Abs[rowop]];
temprow=temp[[cyc[[1]]]];
Do[temp[[cyc[[i]]]]=temp[[cyc[[i+1]]]],{i,Length[cyc]-1}];
temp[[cyc[[-1]]]]=temprow;,rowop==1||ros<=2,r1=If[syros=={ros},ros-1,ros];
{c1}=ChooseRandom[Complement[Range[-mid,mid],{0}],1];
toprows=Complement[Range[1,ros],Join[{r1},syros]];
If[toprows=={},temp[[syros[[1]]]]=temp[[syros[[1]]]]+c1*temp[[r1]];,{r2}=ChooseRandom[toprows,1];
temp[[r1]]=temp[[r1]]+c1*temp[[r2]];
temprow=temp[[r2]];
{r1}=ChooseRandom[Complement[Range[1,ros],{r2}],1];
temp[[r2]]=temp[[r1]];
temp[[r1]]=temprow;];,rowop>1&&ros>2,{r1,r2}=ChooseRandom[Take[Complement[Range[1,ros],syros],-2],2];
{c1,c2}=ChooseRandom[Complement[Range[-mid,mid],{0}],2];
toprows=Complement[Range[1,ros],Join[{r1,r2},syros]];
If[toprows=={},temp[[r2]]=temp[[r2]]+c1*temp[[r1]];
temp[[r1]]=c1*temp[[toprows[[1]]]];
{r1,r2}=ChooseRandom[Range[1,ros],2];
temprow=temp[[r2]];
temp[[r2]]=temp[[r1]];
temp[[r1]]=temprow;,(*toprows nonempty*)temp[[r1]]=temp[[r1]]+c1*temp[[toprows[[1]]]];
temp[[r2]]=temp[[r2]]+c2*temp[[If[Length[toprows]>1,toprows[[2]],toprows[[1]]]]];
cyc=ChooseRandom[Range[1,ros],3];
temprow=temp[[cyc[[1]]]];
Do[temp[[cyc[[i]]]]=temp[[cyc[[i+1]]]],{i,Length[cyc]-1}];
temp[[cyc[[-1]]]]=temprow;]];
(*dependent rows*)If[depros!=0,oldros=ChooseRandom[Complement[Range[1,ros],syros],Abs[depros]+1];
temp=Join[temp,Table[r1=RandomInteger[{1,Max[{mid,4}]}];
temp[[oldros[[i]]]]-r1*temp[[oldros[[i+1]]]],{i,Length[oldros]-1}]]];
temp];
(**end findmatrix**)

Options[FindMatrix]={DependenceData->{0,0},CoefficientData->{9,3,1},EchelonData->{0,0},ReturnRowOps->{0,0},ZeroData->{0,0},SymbolData->{a,0,0,0,0}};

(**************************************************)
(*constructs matrices in reduced echelon form,with specified errors*)

EchelonMatrix[ros_,cols_,rnk_,opts___]:=Module[{err,badcols,goodcols,mtx,cl,badplace,perm},(*collect options*){err}={ErrorType}/.{opts}/.Options[EchelonMatrix];
badcols=If[rnk<3,ChooseRandom[Range[2,cols],cols-rnk],(*else rnk>2*)Join[ChooseRandom[Range[2,cols-1],cols-rnk-1],{cols}]];
goodcols=Complement[Range[1,cols],badcols];
(*initialize*)mtx=Table[0,{ros},{cols}];
(*leading 1*)Do[mtx[[i,goodcols[[i]]]]=1,{i,rnk}];
(*other entries*)Do[mtx[[j,badcols[[i]]]]=RandomInteger[]*entry[7,5,0],{i,Length[badcols]},{j,badcols[[i]]-i}];
(*errors*)If[err==1,(* !=0 elet above leading 1*)badplace=If[rnk==2,1,RandomInteger[{1,rnk (rnk-1)/2}]];
cl=2;
While[badplace>cl (cl-1)/2,cl++];
mtx[[badplace-(cl-1)(cl-2)/2,goodcols[[cl]]]]=entry[7,5,0]];
If[err==2,(*-1 leading entry*)badplace=RandomInteger[{1,rnk}];
mtx[[badplace,goodcols[[badplace]]]]=-1];
If[err==3,(*zero row out of place*)badplace=RandomInteger[{2,rnk}];
perm=Insert[Range[1,ros-1],ros,badplace];
mtx=mtx[[perm]]];
(*return*)mtx];

Options[EchelonMatrix]={ErrorType->0};
(**************************************************)
FindEigenMatrix[rk_,opts___]:=Module[{basic,dev,diag0,rdata,evdata,mtx,diag,zeroplaces,zerows,devplaces,otherplaces,entries,changesign,coefftable,a,okplaces,i,j,prob,ans,output,p,pl,i2,j2},{{basic,dev,diag0},rdata,evdata}={ZeroData,ReturnData,EigenData}/.{opts}/.Options[FindEigenMatrix];
(*find a matrix*)mtx=Table[0,{rk},{rk}];
(*diagonal*)diag=ChooseRandom[Complement[Range[-3,3],{0}],rk-diag0];
diag=Insert[diag,0,ChooseRandom[Table[{i},{i,1,rk-diag0+1}],diag0]];
Do[mtx[[i,i]]=diag[[i]],{i,rk}];
(*other entries*)zeroplaces={};
If[basic<=0,zeroplaces=Join[zeroplaces,Flatten[Table[{i,j},{i,rk-1},{j,i+1,rk}],1]]];
If[basic>=0&&basic<2,zeroplaces=Join[zeroplaces,Flatten[Table[{i,j},{i,1,rk},{j,i-1}],1]]];
zerows=If[basic<=1,{},ChooseRandom[Range[1,rk],basic-1]];
If[zerows!={},zerows[[1]]=((-1)^RandomInteger[])zerows[[1]]];
If[Length[zerows]>1,zerows[[2]]=-Sign[zerows[[1]]]zerows[[2]]];
zeroplaces=Join[zeroplaces,Flatten[Table[p=zerows[[i]];Which[p>0&&j<p,{p,j},p>0&&j>=p,{p,j+1},j<-p,{j,-p},j>=-p,{j+1,-p}],{i,Length[zerows]},{j,rk-1}],1]];
(*deviations*)devplaces=ChooseRandom[zeroplaces,dev];
otherplaces=Union[devplaces,Complement[Flatten[Table[{i,If[j<i,j,j+1]},{i,rk},{j,rk-1}],1],zeroplaces]];
(*fill nonzero places*)entries=ChooseRandom[Complement[Range[-7,7],{0}],Length[otherplaces]];
Do[mtx[[otherplaces[[i,1]],otherplaces[[i,2]]]]=entries[[i]],{i,Length[otherplaces]}];
(*adjust eigenvalues when 2x2+triangular*)If[(basic<2&&dev==1)||(rk-basic==1&&dev==0),{i2,j2}=If[basic<2,Sort[devplaces[[1]]],Complement[Range[1,rk],Abs[zerows]]];];
(*****assemble output,depending on value of rdata********)If[rdata==0,output=mtx];
(*characteristic polynomial*)If[rdata==1,Which[(Abs[basic]<2||rk-basic==0)&&dev==0,(*triangular*)changesign=ChooseRandom[Select[Range[1,rk],diag[[#]]!=0&],1];
coefftable=Table[Table[Coefficient[Product[a-Which[kkk==1,1,kkk==2,-1,kkk==3,If[MemberQ[changesign,i],-1,1],kkk==4,If[MemberQ[changesign,i],1,-1]]*diag[[i]],{i,rk}],a,jjj],{jjj,0,rk}],{kkk,4}];,(basic<2&&dev==1)||(rk-basic==1&&dev==0),(*triangular+2x2*)devplaces=If[basic<2,devplaces[[1]],Complement[Range[1,rk],Abs[zerows]]];
{i,j}=devplaces;
okplaces=Complement[Range[1,rk],devplaces];
coefftable=Table[CoefficientList[Product[a-diag[[okplaces[[iii]]]],{iii,rk-2}]*((a-If[OddQ[kkk],1,-1]diag[[i]])(a-diag[[j]])-If[kkk<2,1,-1]mtx[[i,j]]mtx[[j,i]]),a],{kkk,4}];,True,(*other cases*)coefftable=CoefficientList[Det[mtx-a IdentityMatrix[rk]],a];
coefftable=Table[coefftable,{4}];];
(*fix duplicate answers*)ans=Complement[coefftable[[{2,3,4}]],{coefftable[[1]]}];
If[Length[ans]<3,If[Length[ans]<2,pl=RandomInteger[{1,rk}];
AppendTo[ans,Table[coefftable[[1,i]]+If[i==pl,RandomInteger[{3,4}],0],{i,rk+1}]];];
changesign=Union[ChooseRandom[Select[Range[1,rk],coefftable[[1,#]]!=0&],2]];
AppendTo[ans,Table[coefftable[[1,i]]*If[MemberQ[changesign,i],-1,1],{i,rk+1}]];
AppendTo[ans,Table[ans[[1,i]]*If[MemberQ[changesign,i],-1,1],{i,rk+1}]];
ans=Union[ans];
coefftable[[{2,3,4}]]=ans[[{1,2,3}]];];
output={mtx,coefftable};];(*end ch polynomial*)output];

Options[FindEigenMatrix]={ZeroData->{1,0,0},ReturnData->0,EigenData->0};
(**************************************************)
(*This function creates an integer coefficient 2x2 matrix with a specified determinant (n).*)
msWithDet[n_]:=msWithDet[n]=Select[Outer[{{#1,#2},{#3,#4}}&,Union[Range[-4,4],1/Range[1,4],-1/Range[1,4]],Union[Range[-4,4],1/Range[1,4],-1/Range[1,4]],Union[Range[-4,4],1/Range[1,4],-1/Range[1,4]],Union[Range[-4,4],1/Range[1,4],-1/Range[1,4]]]//Flatten[#,3]&,Det[#]==n&];
(**************************************************)
EigenMatrix[dim_,opts___]:=Module[{cored,rtype,combod,mtx,coredim,evtype,diag0,aaa,bbb,ccc,ddd,t,iii},{cored,rtype,combod}={CoreData,ReturnType,ComboData}/.{opts}/.Options[EigenMatrix];
(*construct core*)If[dim==cored[[1,1]],(*just core*)coredim=cored[[1,1]];
If[coredim==1,mtx=If[cored[[1,2]]==0,{{0}},{ChooseRandom[Complement[Range[-9,9],{0}],1]}]];
If[coredim==2,{diag0,evtype}=cored[[1,2]];
evtype=Mod[evtype,4];
Which[evtype==0,{bbb,ccc}=ChooseRandom[Complement[Range[-4,4],{0}],2];
t=RandomInteger[{2,4}];
If[bbb==t*ccc,t++];
If[diag0==0,{aaa}=ChooseRandom[Complement[Range[-8,8],{0,bbb,ccc}],1];
ddd=aaa+bbb-t*ccc;
bbb=bbb*t;,(*else diag0>0*){aaa,bbb,ddd}=If[RandomInteger[]==0,{0,bbb*t,bbb-t*ccc},{t*ccc-bbb,bbb*t,0}]],evtype==1,{aaa,bbb,ccc}=ChooseRandom[Complement[Range[-8,7],{0}],3];
ddd=aaa+Sign[aaa] RandomInteger[{2,5}];
If[diag0>0,If[RandomInteger[]==0,aaa=0,ddd=0]];
While[t=(aaa-ddd)^2+4 bbb ccc;
t<=0||IntegerQ[Sqrt[t]],If[ddd!=0,ddd=ddd+Sign[ddd],aaa=aaa+Sign[aaa]]];,evtype==2,{iii,bbb,ccc}={{2,1,2},{2,1,5},{2,2,5},{4,1,5},{4,1,8},{4,2,4},{4,4,5},{6,2,5},{6,2,9},{6,3,6},{6,5,5},{6,5,9},{8,4,5},{8,5,5},{8,4,8},{10,5,10},{12,5,8},{12,5,9},{14,5,10}}[[RandomInteger[{1,19}]]];
t=RandomInteger[{0,3}];
{bbb,ccc}=(-1)^t If[t<2,{bbb,-ccc},{ccc,-bbb}];
{t}=If[diag0==0,ChooseRandom[Complement[Range[-9,9-iii],{0,-iii}],1],ChooseRandom[{0,-iii},1]];
{aaa,ddd}=(-1)^RandomInteger[]{t,t+iii};,evtype==3,{aaa,bbb,ccc}=ChooseRandom[Complement[Range[-8,7],{0}],3];
ddd=aaa+Sign[aaa] RandomInteger[{2,5}];
If[bbb ccc>0,bbb=-bbb];
If[diag0>0,If[RandomInteger[]==0,aaa=0,ddd=0]];
While[t=(aaa-ddd)^2+4 bbb ccc;
t>=0||IntegerQ[Sqrt[-t]],bbb=bbb+Sign[bbb]];];
mtx={{aaa,bbb},{ccc,ddd}};];(*end coredim 2*)(*need coredim 3*),(*else not just core*)mtx={{}};];
mtx];

Options[EigenMatrix]={CoreData->{{0,0}},ReturnType->0,ComboData->0};
(**************************************************)
eigenMatrix[dim_,entrySize_]:=eigenMatrix[dim,entrySize,False];

eigenMatrix[dim_,entrySize_,makeTwoTheSame_]:=Module[{A,evecs,s,test=True,evs,notevs},{evs,notevs}=ChooseRandom[Complement[Range[-entrySize-1,entrySize+1],{0}],{{dim},{3}}];
If[makeTwoTheSame,evs[[2]]=evs[[1]]];
While[test,s=0;
While[s==0,evecs=ChooseRandom[Range[-entrySize,entrySize],Table[{dim},{dim}]];
s=Det[evecs];];
A=evecs.DiagonalMatrix[evs].Inverse[evecs];
test=(s>3||s<-3||Count[Flatten[A],0]>=dim);];
{evs,notevs,evecs,A}];
(**************************************************)
(*findquadratic utility.options NrRealRoots->0 or 1 or 2;
Monic->True or False or omit for random;
RationalRoots->True or False or omit for random;
OnlyOneDigit->True or False (if False coeffs may go up to 16) versiondate {2003,12,31}*)

FindQuadratic[opts___]:=Module[
{monic,nrrts,ratl,onedig,skewrts,data,trans,pl,temp,par,a,b,c,r},(*extract option info*)
{monic,nrrts,ratl,onedig,skewrts}={"Monic","NrRealRoots","RationalRoots","OnlyOneDigit","SkewRoots"}/.{opts}/.Options[FindQuadratic];
(*resolve uncertainties*)
ratl=If[ratl,ratl,ratl,RandomInteger[]==0];
monic=If[monic,monic,monic,RandomInteger[If[nrrts===1,1,3]]==0];
onedig=If[onedig,onedig,onedig,False];
If[ratl,If[!MemberQ[{0,1,2},skewrts],skewrts=3];
If[skewrts==0,nrrts=2,If[!MemberQ[{0,1,2},nrrts],nrrts=2 RandomInteger[]]];
(*bifurcate nrrts==2*)nrrts=If[nrrts==2&&(skewrts==2&&RandomInteger[2]==0||skewrts==1&&RandomInteger[3]==0),3,nrrts];
data={{{{2,4,1,5},{2,6,1,10},{4,6,1,13}},{{4,8,4,5},{2,6,2,5},{6,8,5,5},{2,10,2,13}}},{{{2,2,1,1},{4,4,1,4},{6,6,1,9},{8,8,1,16}}},{{{1,5,1,6},{4,6,1,5},{2,4,1,3},{2,6,1,8},{1,3,1,2},{3,5,1,4},{3,7,1,10},{5,9,1,14},{2,8,1,15},{1,7,1,12}},{{1,5,2,3},{2,8,3,5},{4,8,3,4},{1,7,2,6},{1,7,3,4},{3,5,2,2},{3,7,2,5},{3,9,2,9},{3,9,3,6},{5,9,2,7},{4,10,3,7},{1,9,2,10},{2,10,3,8}}},{{{5,7,1,6},{6,8,1,7},{7,9,1,8},{8,10,1,9}},{{5,7,2,3},{7,9,2,4},{8,10,3,3}}}}[[nrrts+1]];
trans={{{1,3},{3,4}},{{3,0},{4,0}},{{6,10},{10,13}},{{3,2},{4,3}}}[[nrrts+1,If[onedig,1,2]]];
trans=trans-{If[nrrts==2&&skewrts<3,1,0],If[nrrts==2&&skewrts==2,If[onedig,1,2],0]};
If[monic,pl=RandomInteger[{1,trans[[1]]}];
pl=pl+If[nrrts==2&&(skewrts==2||(skewrts==0&&pl>1)),1,0];
temp={data[[1,pl]],0};,(*else not monic*)pl=RandomInteger[{1,trans[[1]]+2 trans[[2]]}];
temp=Which[pl<=trans[[1]],{data[[1,pl+If[nrrts==2&&(skewrts==2||(skewrts==0&&pl>1)),1,0]]],1},pl<=trans[[1]]+trans[[2]],{data[[2,pl-trans[[1]]+If[nrrts==2&&skewrts==2,1,0]]],0},True,{data[[2,pl-trans[[1]]-trans[[2]]+If[nrrts==2&&skewrts==2,1,0]]],1}];];
par=Which[nrrts==2&&skewrts==0,1,nrrts==2&&skewrts==2,2,temp[[1]]=={4,8,4,5}||temp[[1]]=={2,4,1,5},1,temp[[1]]=={5,7,2,3}||temp[[1]]=={5,7,1,6},2,True,1+RandomInteger[]];
b=(-1)^RandomInteger[] temp[[1,par]];
{a,r}=temp[[1,If[temp[[2]]==0,{3,4},{4,3}]]];
c=r*If[nrrts>1&&par==1,-1,1];];
If[Not[ratl],(*else not ratl*)If[!MemberQ[{0,1,2},nrrts],nrrts=2 RandomInteger[]];
If[nrrts==0,skewrts=2,If[!MemberQ[{0,1,2},skewrts],skewrts=2RandomInteger[]]];
{a,b,r}=FindQuadratic["RationalRoots"->True,"NrRealRoots"->skewrts,"SkewRoots"->nrrts,"Monic"->monic,"OnlyOneDigit"->onedig];
c=-1*r;];
{a,b,c}/GCD[a,b,c]];

Options[FindQuadratic]={"Monic"->Maybe,"NrRealRoots"->"Unspecified","RationalRoots"->Maybe,"OnlyOneDigit"->False,"SkewRoots"->"Unspecified"};


(**************************************************)
(*XML generating utilities
accepts specially formatted data structure:
data = String | {item,{data,data,...}}
item = String | {nodeName,{attrName,attrValue},{attrName,attrValue},...}

 Usage
makeXMLDocument[
{{"root",{"id","none"},{"class","none"}},
{"item",
"text",
{"item",
"text"
},
{{"item",{"special","yes"}},
"Special text"
},
{"item",
"text"
}
},
{"item",{"item"}}
}]
*)


makeXMLDocument[data_List]:=StringJoin["<?xml version='1.0' encoding='UTF-8'?>",makeXMLNode[data]];
makeXMLNode[node_List]:= 
If[Length[node]==1,
StringJoin["<",openXMLNode[node[[1]]],"/>\n"],
StringJoin["\n<",openXMLNode[node[[1]]],">",StringJoin@@Map[makeXMLNode[#]&,Drop[node,1]],"</",closeXMLNode[node[[1]]],">"]
]

makeXMLNode[text_String]:=StringReplace[ExportString[XMLElement["t",{},{text}],"XML","Entities"->"HTML"],{StartOfString~~"<t>"->"","</t>"~~EndOfString->""}]

openXMLNode[name_String]:=name
closeXMLNode[name_String]:=name

openXMLNode[list_List]:=StringJoin[
ToString[list[[1]]],
makeXMLAttributes[Drop[list,1]]
]
closeXMLNode[list_List]:=ToString[list[[1]]]

makeXMLAttribute[attr_List]:=StringJoin[" ",ToString[attr[[1]]],"='",ToString[attr[[2]]],"'"]
makeXMLAttributes[attrs_List]:=Apply[StringJoin,Map[makeXMLAttribute,attrs,{1}]]
(*end of XML utilities*)

(*HTML utilities*)
(*Wraps LaTeX for MathJax rendering*)
htmlLatex=StringJoin["<script type='math/tex'>",#,"</script>"]&;

(*Wraps LaTeX for MathJax rendering in display mode*)
htmlLatexDisplay=StringJoin["<script type='math/tex; mode=display'>",#,"</script>"]&;

(*Wrap the text in appropriate HTML tags to be displayed as a problem prompt*)
Options[htmlPrompt]={promptId->""};
SetOptions[htmlPrompt,promptId->""];

htmlPrompt [title_String,body_String,OptionsPattern[]]:=StringJoin["<div><h2>"<>title<>"</h2></div><div promptId='"<>OptionValue[promptId]<>"'><p>"<>body<>"</p></div>"];
htmlPrompt [body_String,OptionsPattern[]]:=StringJoin["<div promptId='"<>OptionValue[promptId]<>"'><p>"<>body<>"</p></div>"];

(*Generate an input field*)
htmlInputField [fieldId_,OptionsPattern[]]:="<span class='inputfield' style='font-size: 100%; font-family: STIXGeneral-Regular; ' contenteditable='true' fieldId = '"<>fieldId<>"'></span>"
(*Set default options for htmlInputField*)
Options[htmlInputField] = {Enabled->True};
SetOptions[htmlInputField,Enabled->True];


(*Put all input fields together and supply them with a 'Submit' button*)
htmlInputFieldBuilder [ problemId_,prompt_, fields_,OptionsPattern[]]:=
StringJoin["<div promptId = '",problemId,"' class='inputbox'>",prompt,"&nbsp;",fields<>"&nbsp;<input promptId = '",problemId,"' class='evalButton' type='button' value='Submit'",If[OptionValue[Enabled],""," disabled='true'"]," />&nbsp;<span id='resultsField",problemId,"'></span></div>"]
(*Set default options for htmlInputFieldBuilder*)
Options[htmlInputFieldBuilder] = {Enabled->True};
SetOptions[htmlInputFieldBuilder,Enabled->True];
(*end of HTML utilities*)

(*Set default options for makeproblem*)
Options[makeproblem] = {Enabled->True};
SetOptions[makeproblem,Enabled->True];
On[General::"spell1"];
On[General::"spell"];

